use std::mem::ManuallyDrop;

// An implementation of the `Result` type using explicitly tagged unions
//
// fix the TODOs, and veryify that your implementation mirrors the one of `std::result::Result`
// using tests.
//
// > cargo test -p F3-tagged-union

/// RocResult matches the memory layout of a result type generated by the roc compiler. By
/// mirorring the layout on the rust side, values can be passed between roc and rust without any
/// (de)serialization cost
struct RocResult<T, E> {
    tag: RocResultTag,
    payload: RocResultUnion<T, E>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum RocResultTag {
    Ok,
    Err,
}

// HINT: read the documentation of ManuallyDrop, and see what methods it provides
union RocResultUnion<T, E> {
    ok: ManuallyDrop<T>,
    err: ManuallyDrop<E>,
}

impl<T, E> Drop for RocResult<T, E> {
    fn drop(&mut self) {
        // implement drop. Make sure values wrapped in a ManuallyDrop are dropped correctly!
        match self.tag {
            RocResultTag::Ok => unsafe { ManuallyDrop::drop(&mut self.payload.ok) },
            RocResultTag::Err => unsafe { ManuallyDrop::drop(&mut self.payload.err) },
        }
    }
}

impl<T: Clone, E: Clone> Clone for RocResult<T, E> {
    fn clone(&self) -> Self {
        match self.tag {
            RocResultTag::Ok => RocResult {
                tag: RocResultTag::Ok,
                payload: RocResultUnion {
                    ok: unsafe { self.payload.ok.clone() },
                },
            },
            RocResultTag::Err => RocResult {
                tag: RocResultTag::Err,
                payload: RocResultUnion {
                    err: unsafe { self.payload.err.clone() },
                },
            },
        }
    }
}

impl<T, E> RocResult<T, E> {
    fn unwrap(mut self) -> T {
        let t = match self.tag {
            RocResultTag::Ok => unsafe { ManuallyDrop::take(&mut self.payload.ok) },
            RocResultTag::Err => panic!("Called `unwrap` on an Err"),
        };
        std::mem::forget(self);
        t
    }

    fn unwrap_err(mut self) -> E {
        let e = match self.tag {
            RocResultTag::Ok => panic!("Called `unwrap_err` on an Ok"),
            RocResultTag::Err => unsafe { ManuallyDrop::take(&mut self.payload.err) },
        };
        std::mem::forget(self);
        e
    }

    fn ok(v: T) -> Self {
        RocResult {
            tag: RocResultTag::Ok,
            payload: RocResultUnion {
                ok: ManuallyDrop::new(v),
            },
        }
    }

    fn err(e: E) -> Self {
        RocResult {
            tag: RocResultTag::Err,
            payload: RocResultUnion {
                err: ManuallyDrop::new(e),
            },
        }
    }

    fn is_ok(&self) -> bool {
        matches!(self.tag, RocResultTag::Ok)
    }

    fn is_err(&self) -> bool {
        matches!(self.tag, RocResultTag::Err)
    }

    fn map<F, U>(mut self, f: F) -> RocResult<U, E>
    where
        F: FnOnce(T) -> U,
    {
        let r = match self.tag {
            RocResultTag::Ok => {
                RocResult::ok(f(unsafe { ManuallyDrop::take(&mut self.payload.ok) }))
            }
            RocResultTag::Err => {
                RocResult::err(unsafe { ManuallyDrop::take(&mut self.payload.err) })
            }
        };
        std::mem::forget(self);
        r
    }
}

impl<T, E> From<RocResult<T, E>> for Result<T, E> {
    fn from(mut value: RocResult<T, E>) -> Self {
        let r = match value.tag {
            RocResultTag::Ok => Ok(unsafe { ManuallyDrop::take(&mut value.payload.ok) }),
            RocResultTag::Err => Err(unsafe { ManuallyDrop::take(&mut value.payload.err) }),
        };
        std::mem::forget(value);
        r
    }
}

impl<T, E> From<Result<T, E>> for RocResult<T, E> {
    fn from(value: Result<T, E>) -> Self {
        match value {
            Ok(v) => RocResult::ok(v),
            Err(err) => RocResult::err(err),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_is_ok() {
        let ok: RocResult<i32, String> = RocResult::ok(42);

        assert!(ok.is_ok());
        assert!(Result::from(ok).is_ok());
    }

    #[test]
    fn test_is_err() {
        let err: RocResult<(), i32> = RocResult::err(42);

        assert!(err.is_err());
        assert!(Result::from(err).is_err());
    }

    #[test]
    fn test_map() {
        let ok: RocResult<i32, i128> = RocResult::ok(42);

        let ok = ok.map(|n| format!("{n}"));

        assert_eq!(ok.unwrap(), "42");
    }

    #[test]
    fn test_clone_ok() {
        let ok: RocResult<i32, i128> = RocResult::ok(42);

        let ok = ok.map(|n| format!("{n}"));

        let std_ok = Result::from(ok.clone());

        assert_eq!(ok.unwrap(), std_ok.unwrap());
    }

    #[test]
    fn test_clone_err() {
        let err: RocResult<i32, String> = RocResult::err(String::from("Hello World!"));

        let std_err = Result::from(err.clone());

        assert_eq!(err.unwrap_err(), std_err.unwrap_err());
    }
}

fn main() {
    println!("Hello, world!");
}
